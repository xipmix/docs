{"pages":[{"title":"Volumio Documentation","text":"\u00c2\u00a0 Welcome to Volumio's documentation Volumio is a GNU\\Linux Based Audiophile Music Player Operating system. designed to play music with the highest possible fidelity. Altough its designed to run on most embedded devices (Raspberry Pi, UDOO, Odroid, Cubieboard, Beaglebone...) it works great also on any ordinary PC. To get more informations visit the Overview section. Quick links \u00c2\u00a0 Volumio uses Websockets to receive commands, see how it works in the WebSocket API Section Learn how to write plugins to add new functionalities to Volumio in the Plugin Section Want to contribute to this guide? See the Contribute to this doc Section Troubles mounting an NFS Share? See how to Mount a NFS Share Did you know that Volumio has a command line client? Here's how to use the Command Line Client","tags":"","url":"index.html"},{"title":"Quick Start Guide","text":"Quick start guide First Boot Volumio's first boot will take usually longer, up to 6 minutes if you're on a Raspberry PI 1. Therefore, be patient of first boot and wait about 5 minutes before starting to use Volumio. The first time Volumio starts, it will perform some operations: Extend the filesystem to fill completely your SD Card\\ Hard drive Regenerate SSH keys, to make them unique to your device Install some packages and configure the system Generate new thumbnails for the default backgrounds Network connection Volumio works best when its connected to your Network, since it's meant to be used in an headless state: no monitor connected, and controlled via another device (PC, smartphone, tablet etc) To connect Volumio to your network, simply attach an ethernet cable to it before starting it up If no ethernet is available, you can connect to its hotstpot (see below) and connect to your Wi-fi Network. To do so, go to settings -&gt; Network and connect it from there IMPORTANT Do not configure your network manually via SSH, this can lead to issues and malfunctions Volumio Hotspot If your device has wireless capabilities (and a supported Wireless card) Volumio will create a Wireless Network called Volumio, the default password is volumio2 The Hotspot mode will allow you to connect to your Wireless Network without the need to a wired connection, just connect to Volumio Hotspot and configure your network on network options Once your Wireless network has been configured, the Hotspot will no longer be visible If, for whatever reason, your configured Wireless network is not available, Volumio will automatically re-enable the Hotspot You can change the Hotspot options in the Network options, such as its name, password and channel (useful if you experience poor Hotspot performances) Once in Hotspot Mode, Volumio can be reached with IP 192.168.211.1 or via http:\/\/volumio.local as usual UI connection The UI can be accessed from any device with a browser: Tablets, PC, Mac, Android Phones, iPhones, Smart TVs, Ebook readers etc. Make sure you have the latest versions of their respective browsers. For an optimal experience, Google Chrome is suggested. The UI can be accessed by typing Volumio's IP address on your browser. To find the IP address you can use: ANDROID FING iOS Net Analyzer Chrome mDNS Browser Volumio UI can also be accessed by typing http:\/\/volumio.local, or if you renamed your Volumio device http:\/\/VOLUMIONAME.local . Please note that this function is not available on Android devices, just on Mac and iOs or in Windows (if that does not work, install Bonjour )","tags":"","url":"User_Manual\/Quick_Start_Guide.html"},{"title":"System updates","text":"Volumio OTA Updater Volumio features an OTA (Over The Air) updater, meant to allow seamless and reliable way to update to new system versions. This is what the Volumio OTA updater allows: Volumio uses a cloud-based build mechanism for its images, which includes the updater control backbone 1:1 verified updates of new versions, this ensures that new updates are deployed exactly as they are built Differential download: instead of downloading the full firmware, Volumio will download just the differences beetween the current system and the new one. This allows to save up to 90% of download size, resulting also in faster downloads User-data preservation: updating to a new version will keep user data (such as playlists, music files, settings) untouched Ability to reset to factory settings: doing so will revert the system to the first version it was booted to. This will cancel both user data and newer system versions Ability to wipe user-data: doing so will reset all settings to factory defaults, while keeping the last firmware version installed. How to use the OTA updater Verify that your Volumio device is connected to the Internet Click on the cog-wheel in the top right part of the UI Select system Click on &quot;Check Updates&quot; If an update is available, you'll be presented with the new features. Click on &quot;Update Now&quot; System update will start, and depending on the update size it might take up to 20 minutes Once Update has finished, you'll be asked to reboot. Do it The system will now restart, and new version will be applied Use the system updater to test Beta-Releases Volumio can be updated to Beta Releases via OTA Updater. Beta-releases are test builds of the system with undisclosed functionalities Beta releases are meant to test new functionalities before deploying an update to the entire Volumio userbase Beta releases might not work, or present bugs still to be solved. They are therefore meant for expert users willing to take the risk to loose all their data To receive beta-releases, the system has to be put in &quot;TEST MODE&quot;. To do so, navigate to http:\/\/volumio.local\/dev or http:\/\/yourvolumioip\/dev Once in the \/dev page, click on &quot;TRUE&quot; on &quot;TEST MODE&quot; Section. Your device is now in TEST MODE, and will receive test updates from now on Follow the above instructions to update your system normally, the only difference is that you'll see the test releases in spite of ordinary releases Disable TEST MODE To disable test mode, navigate to \/dev page and click &quot;FALSE&quot; on &quot;TEST MODE&quot; section. You will now receive only ordinary releases In case you want to revert to old stable release, do a factory reset and then update to latest stable version (this will erase all your data) Considerations over OTA Updater If you're an advanced user and do usually manual settings to the system (e.g. manual changes of config files via SSH, update volumio backend via GIT etc) , we strongly suggest not to USE the OTA updater, since your manual changes will impact the consistency of the updates","tags":"","url":"User_Manual\/System_updates.html"},{"title":"Volume Control and audio quality","text":"Volume Controls and Audio Quality Introduction It's not true that enabling volume control ALWAYS tampers with bit perfect. There are 2 ways to get Volume control: Software mixer: the audio streaming is manipulated to get the desired volume change. This makes the stream not bitperfect, and degrades sound quality Hardware Mixer: its not supported by every DAC, but if the DAC supports this, it will trigger its array of internal resistors to change the volume. In this mode, you can change the volume while keeping bit perfect and without any audio quality degradation. How to get the best sound and Volume Control Volumio can detect if your DAC supports Hardware mixer, and enable it automatically. If your DAC does not support it, Volumio will allow you to enable software mixer. To change this behaviour you can go to Playback Options -&gt; Volume Settings: Select the Mixer Type: None = No volume control Software = Volume control but loss of Audio Quality Hardware = Best of both worlds, provides ability to change volume without loss of quality","tags":"","url":"User_Manual\/Volume_Control_and_audio_quality.html"},{"title":"Configure MPD Clients for albumart","text":"When starting the MPod app for the first time: Select &quot;Add payer manually&quot; and fill in the following information: Connection - Name: Volumio MPD - Server: ip address of your volumio device (or volumio.local , or in case you renamed it volumioname.local) Local Cover Art - URL: volumio.local\/cover-art Local Cover Art - Cover Filename: folder.jpg Leave all other settings at the default. Important note: The cover art URL including the file name is case sensitive, all your music folders need to use the same casing. (folder.jpg != Folder.jpg)","tags":"","url":"User_Manual\/Configure_MPD_Clients_for_albumart.html"},{"title":"Sending logs for troubleshooting","text":"Sending logs for Troubleshooting When your Volumio device does not work as expected, crashes or fails in particular conditions, the only way to understand what goes wrong is usually by looking at logs. So, if you experience such problems, please follow this guide to report your issue to developers. Volumio features an integrated facility to collect logs of your system and publish them in a way to offer developers a clear way to understand what is broken on your system. How to send a bug report Navigate to http:\/\/volumio.local\/dev or http:\/\/yourvolumioip\/dev This will open the &quot;DEV&quot; page Scroll until you see a section called &quot;Send logs of bug report&quot; Fill the text field with a clear, but short description of your problem Click on Send Once the logs have been successfully sent, you will see a link like &quot;http:\/\/logs.volumio.org\/xxxxxx&quot; Press the copy button to copy the link to your logs in your clipboard Paste this log wherever you're requesting for help: a forum thread, a githhub issue or a mail If possible, write a very detailed step-to-step guide on how to replicate the problem","tags":"","url":"User_Manual\/Sending_logs_for_troubleshooting.html"},{"title":"Overview","text":"Volumio is an headless audiophile music player, designed to play music with the highest possible fidelity. Volumio runs on most embedded devices (Raspberry Pi, UDOO, Odroid, Cubieboard, Beaglebone...) and on any ordinary PC (x86). Components Volumio is obtained with 3 main components: Node.js Backend (this repository) This is Volumio core infrastructure. The Volumio2 backend runs on your device and accepts connections from different user interfaces (see later). Angular.JS Frontend This is Volumio's integrated WebUI. It is deployed in \/volumio\/http\/www folder Debian based minimal OS This is Volumio's build script: launch it in a Debian or Ubuntu install, to obtain a complete Volumio Image. Logins Logins user : volumio Password : volumio Root login has been disabled by default for security reasons , however user volumio can become root. Development 101 To maximize efficiency and reduce code regression we're using Git Workflow. For example, to create a new feature you'll: Create a new branch, named after the feature Do your things on the branch Test if everything is fine and we don't have regressions Submit a Pull Request for branch dev All new improvements and developments are meant to be done on the dev branch, once it's declared stable it will be merged to master and deployed to happy Volumio users. Development Guidelines Forum Threads for internal discussion, remember to subscribe topics. Document your work where possible on the Wiki. This is intended to run on Low Power Devices (r-pi). Let's keep code efficient and lightweight. To allow code mantainability, always comment your code properly and update DOCs if needed. Adhere to MVC Best Practices to maximize project quality. Have fun and enjoy what you're doing!","tags":"","url":"Development_How_To\/Overview.html"},{"title":"System Architecture","text":"System Architecture There are two halves of this project on the server side: Volumio OS and the Volumio Core. The Volumio OS is a customized Debian Jessie distribution and ecosystem of software packages which serves as the framework for the system. The Volumio Core is a serverside application (written in Javascript) which runs the music player, music library, and other functions. Architecture Overview Volumio Core has an MVC-like architecture which breaks the player functionality into modules. The modules are organized by function: clients, interfaces, core, controllers, services, and output. Clients The clients represent anything that can open a connection with the Volumio server and send commands. This is code that runs on the client machine, whether it be a PC, tablet, phone, or watch. The Volumio WebUI is one of the possible clients you can use to connect to the Volumio server. It communicates to the server using a standard websocket protocol. And since this is a standard protocol, users may code any other web interface they want, and have it drive Volumio. We also have many users who use MPD clients to drive Volumio. Volumio2 will have a dedicated MPD emulation interface which will be able to interact with your favorite MPD controller. Interface Plugins Which brings us to our next group of modules, the interfaces. Interfaces serve as the intermediaries between the clients and the Volumio core. They translate what are typically text commands into function calls that the core executes. These interface modules are designed to be interchangeable - they offer a set of standard methods that the core can call, and return data in a standard format. We are developing this standard as we go, but the general idea is that users can drop in their own interface modules, which will allow for more interface options than just websocket and MPD emulation. For example, one could write an interface module for hard controls (real knobs and buttons, imagine that!), for local kiosk-style control, etc. Core Modules The core modules run the logic behind the Volumio player. The state machine module contains logic for switching between player states like play, pause, and stop. The play-queue module maintains the list of tracks which are queued up to play. The play queue may contain tracks from any music service. The music library module (more about this later) maintains a database of all the tracks across all services that the user has active. and allows for browsing and searching. The device selector would allow a user to switch between different output sinks - this is yet to be coded, I'm still trying to figure out what this means! The volume module allows for hardware or software level control of the output volume. Finally, the command router module contains no logic, it merely routes function calls to the various other modules. Music Controller Plugins The music controllers are modules which can communicate with individual music services or daemons. Each music service will have its own controller module. The controller can retrieve music information from the service or daemon, and can also send commands to control playback. It is important to note here that each music daemon likely has its own built in play queue and playback status. The Volumio state machine keeps in sync with each of these separate play queues and statuses. This allows the user to interact with Volumio as if it were a single music player, and the Volumio Core controls each of the music services separately in the background. We are currently planning controllers for MPD, Spop, and possibly GMusic. We are also going to add a controller for Libgroove, a nice local audio renderer that can serve as an alternative to MPD. Libgroove uses libav for audio decoding (the same as what VLC uses). Each music controller module will be interchangeable like the user interface modules. Users can write controllers for new music services they would like to add. Music Services The music services are music player daemons or interfaces to online music sources. Some of these will come bundled as part of the Volumio OS, but users can install their own as well. Output Stack The audio output stack is comprised of system-level controllers and other handlers. Under the most basic setup, this only requires ALSA, the system-level interface to your DAC. There is also the option to add SOX into the stack, which would allow for manipulation of audio data. One of the requests we often hear is for multi-room streaming and other output device selection options. Those features would probably go in this output stack somewhere. Currently, I'm still hazy on how this might work, so anyone feel free to jump in with advice! Technologies Used Node.js as the serverside application framework Socket.io for websocket communication Express as the HTTP webserver for the Volumio WebUI Angular as the WebUI framework LevelDB as the persistent database system Kew to run the promise-based asynchronous execution of code (click here to learn what a promise is)","tags":"","url":"Development_How_To\/System_Architecture.html"},{"title":"Set up a development environment","text":"Development environment In order to develop new functionalities of Volumio, depending on which part you want to improve, you need to set up a development environment. Volumio is designed to be an highly integrated system. This means that the WebUi is optimized to work along with the custom made Volumio system, and therefore it needs to run in a very tightly controlled environment. IT WON'T WORK on standard Raspbian or other non-volumio OSes. If you want to know what kind of customizations we're using, take a look at the Volumio Builder So, we suggest to have a running Volumio device connected to your local network, while developing on your machine. Setting up a development environment for Volumio2 NODE Backend In this scenario, we will develop direclty on the Volumio device, but editing the main files on your PC\\MAC. There are several ways to achieve such result Mount the \/volumio directory of your device to a Folder on your system via sftp (volumio:volumio) Use an IDE that allows remote deplyoment (like Atom or Webstorm which we suggest since its simply awesome!) When you make changes to any file of Volumio, you can restart the service with killall node or systemctl restart volumio You can see all logs, generated both by the system and Volumio with sudo journalctl -f So, ideally, you'll want to: Edit the files from your editor of choice Upload changes to the Volumio device Restart NODE Services See the effects via an SSH connection, with sudo journalctl -f IMPORTANT: If you want to develop on the latest version, you can simply launch this command to obtain the latest code on master branch: volumio pull Setting up a development environment for Volumio2 UI Volumio2 UI is an AngularJS based WebAPP. You can develop on it from your PC\\MAC but you need to have a Volumio device on your network. The UI communicates with Volumio's backend via WebSockets using Socket.io Socket.io To set up a development environment on your PC\\MAC do: Install dependencies (only firt time) Download and install Node.js Download and install Bower Download and install Gulp Prepare Volumio2 UI Development folder Clone the UI with: git clone https:\/\/github.com\/volumio\/Volumio2-UI We suggest developing on the development branch, and to push your Pull requests there: cd Volumio2-UI git checkout development Install npm dependencies npm install Install bower dependencies bower install Tell the UI where our Volumio instance is : Now, you can develop on it, while retrieving data from Volumio2 backend (you must have a Volumio2 device on your network and know its IP address). To tell the UI where to find Volumio 2 backend, create a file with the IP of Volumio2 in \/src\/app\/local-config.json The file will look like { &quot;localhost&quot;: &quot;http:\/\/192.168.31.234&quot; } Now, feel free to edit and see live changes on a local browser with dynamically generated UI. To do so: gulp serve --theme=&quot;volumio&quot; Once finished, to deploy on Volumio 2, first build it. if you want production optimization use --env=&quot;production&quot; gulp build --theme=&quot;volumio&quot; --env=&quot;production&quot; And deploy by copying the content of dist directory on Volumio2 device to: \/volumio\/http\/www Setting up a development environment for Volumio 2 images We suggest to develop on a debian based environment Install dependencies git squashfs-tools kpartx multistrap qemu-user-static samba debootstrap parted dosfstools qemu binfmt-support qemu-utils Set up development folder clone the build repo on your local folder : git clone https:\/\/github.com\/volumio\/Build build if on Ubuntu, you may need to remove $forceyes from line 989 of \/usr\/sbin\/multistrap cd to \/build and type .\/build.sh -b &lt;architecture&gt; -d &lt;device&gt; -v &lt;version&gt; where switches are : -b &lt;arch&gt; Build a full system image with Multistrap. Options for the target architecture are arm or x86. -d &lt;dev&gt; Create Image for Specific Devices. Supported device names: pi, odroidc1\/2\/xu4\/x2, udoo, cuboxi, bbb, cubietruck, compulab, x86 -l &lt;repo&gt; Create docker layer. Give a Docker Repository name as the argument. -v &lt;vers&gt; Version Example: Build a Raspberry PI image from scratch, version 2.0 : .\/build.sh -b arm -d pi -v 2.0 -l reponame You do not have to build the architecture and the image at the same time. Example: Build the architecture for x86 first and the image version MyVersion in a second step: .\/build.sh -b x86 .\/build.sh -d x86 -v MyVersion","tags":"","url":"Development_How_To\/Set_up_a_development_environment.html"},{"title":"Debugging","text":"Debugging Volumio2 Backend Debugging Volumio 2 with Webstorm from Shaggy Dog on Vimeo.","tags":"","url":"Development_How_To\/Debugging.html"},{"title":"API Overview","text":"","tags":"","url":"API\/API_Overview.html"},{"title":"WebSocket APIs","text":"Introduction The most used API transport in Volumio2 is its Websockets API as it allows almost real time communication with multiple clients. Volumio's WebUI gets and sends data (almost) exclusively via WS. Volumio's WS layer is powered by Socket.io. The WebSocket API interface is located at: https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/app\/plugins\/user_interfaces\/websocket\/index.js Scenarios Websocket communication in Volumio is identifiable in the most basic server\/client architecture. The Server is Volumio itself (aka the host where Volumio is running), the client can be one or more WebUIs or other consumers (Apps and so on). In some cases, Volumio hosts can also act as client, to communicate with other hosts on the same network. Events Socket.io allows to invoke events triggered by other events, emit and receive communications (on its most basic implementation). As an example, defining which event should be invoked on a client connection looks like: self.libSocketIO.on('connection', function (connWebSocket) { \/\/ use connWebSocket here }); This way, we can define what event should be triggered when a particular message is received: connWebSocket.on('bringmepizza', function () { givehimpizza(); }); Typically, every message we send or receive to Volumio's Backend will have this structure: io.emit('message','data'); Where message can be for example &quot;play&quot; and data can be the song number. A good policy for sending data on emits is to configure them as objects: they're easier to parse and easily extendable. So our message can be: io.emit('addToPlaylist', {&quot;name&quot;: &quot;Music&quot;, &quot;service&quot;: &quot;mpd&quot;, &quot;uri&quot;: &quot;music-library\/...&quot;}); Events Documentation Basic Playback Commands **Play:** play **Pause:** pause **Stop:** stop **Previous:** prev **Next:** next **Seek** seek N (N is the time in seconds that the playback will keep) **Random** setRandom(true|false) **repeat** setRepeat(true|false) Get Player State GetState Reply: {&quot;status&quot;:&quot;play&quot;, &quot;position&quot;:&quot;0&quot;, &quot;title&quot;:&quot;Macaco&quot;, &quot;artist&quot;:&quot;Paolo Conte&quot;, &quot;album&quot;:&quot;Paolo Conte&quot;, &quot;albumart&quot;:&quot;http:\/\/img2-ak.lst.fm\/i\/u\/300x300\/1b82dd5e54554209bf2326ffb76f6814.png&quot;, &quot;seek&quot;:&quot;25390&quot;, &quot;duration&quot;:&quot;146&quot;, &quot;samplerate&quot;:&quot;44100&quot;, &quot;bitdepth&quot;:&quot;16&quot;, &quot;channels&quot;:&quot;2&quot;, &quot;volume&quot;:&quot;100&quot;, &quot;mute&quot;:&quot;false&quot;, &quot;service&quot;:&quot;mpd&quot;} Where status is the status of the player position is the position in the play queue of current playing track (if any) title is the item's title artist is the item's artist album is the item's album albumart the URL of AlbumArt (via last.fm APIs) seek is the item's current elapsed time duration is the item's duration, if any samplerate current samplerate bitdepth bitdepth channels mono or stereo volume current Volume mute if true, Volumio is muted service current playback service (mpd, spop...) Search search {value:'query'} Where query is my search query. (note that for using live search, DO NOT send queries with less than 3 characters, they will dramatically slow search operations). Volume Set to percentage, raise or lower, mute or unmute. Message: volume Data: numeric value between 0 and 100 mute umute + - Example io.emit('volume', 90); io.emit('volume', '+'); Mute Message: mute Example io.emit('mute', ''); Unmute Message: unmute Example io.emit('unmute', ''); Multiroom getMultiRoomDevices Retrieves all devices connected to the same network. Input: None Output (through pushMultiRoomDevices socket.io event): { &quot;misc&quot;: {&quot;debug&quot;: true}, &quot;list&quot;: [ { &quot;id&quot;:&quot;uuid&quot;, &quot;host&quot;:&quot;&quot;, &quot;name&quot;:&quot;&quot;, &quot;isSelf&quot;:true|false, &quot;state&quot;: { &quot;status&quot;: &quot;&quot;, &quot;volume&quot;: 0, &quot;mute&quot;: true|false, &quot;artist&quot;: &quot;&quot;, &quot;track&quot;: &quot;&quot; }, { &quot;id&quot;:&quot;uuid&quot;, &quot;host&quot;:&quot;&quot;, &quot;name&quot;:&quot;&quot;, &quot;isSelf&quot;:true|false, &quot;state&quot;: { &quot;status&quot;: &quot;&quot;, &quot;volume&quot;: 0, &quot;mute&quot;: true|false, &quot;artist&quot;: &quot;&quot;, &quot;track&quot;: &quot;&quot; } ] } Browse Music Library browseLibrary objBrowseParameters Where objBrowseParameters are the parameters we want to dig into. This returns the desired level in the music library along with navigation and pagination informations. { navigation: { prev: { uri: '' }, list: [ {service: 'mpd', type: 'song', title: 'track a', artist: 'artist a', album: 'album', icon: 'music' uri: 'uri'}, {type: 'folder', title: 'folder a', icon: 'folder-open-o' uri: 'uri'}, {type: 'folder', title: 'folder b', albumart: '\/\/ip\/image' uri: 'uri2'}, {type: 'playlist', title: 'playlist', icon: 'bars' uri: 'uri4'} ] } } The browsable items can be; Track Folder (can also be a category) Playlist Their parameters are: Type: track, folder, category Title: If this is a song: title, if folder or category is their name. Artist and Album: used only if the type is song Icon or image: Select the icon to display (naming of Font-Awesome ) , or image (URL served by Volumio Backend or external service) Uri: Uri Get Music Library Available filters getBrowseFilters This returns available filters (browse by) {name:'Genres by Name', index: 'index:Genres by Name'}, {name:'Artists by Name', index: 'index:Artists by Name'}, {name:'Albums by Name', index: 'index:Albums by Name'}, {name:'Albums by Artist', index: 'index:Albums by Artist'}, {name:'Tracks by Name', index: 'index:Tracks by Name'} Get Music Sources getBrowseSources This returns a list of available Music Sources {name:'USB', uri: 'usb'}, {name:'NAS', uri: 'nas'}, {name:'Web Radio', uri: 'web-radio'}, {name:'Spotify', uri: 'spotify'} Custom Browse Source This can be useful when creating a new plugin, to inject custom views in the browse sources panel, along with top-level custom actions. { &quot;name&quot;: &quot;Custom Source&quot;, &quot;pluginName&quot;: &quot;streaming_controller&quot;, &quot;pluginType&quot;: &quot;music_service&quot;, &quot;uri&quot;: &quot;stream&quot;, &quot;info&quot;: &quot;Additional info&quot;, &quot;menuItems&quot;: [ { &quot;name&quot;: &quot;play&quot;, &quot;socketCall&quot;: { &quot;emit&quot;: &quot;callMethod&quot;, &quot;payload&quot;: { &quot;endpoint&quot;: &quot;music_service\/streaming_controller&quot;, &quot;method&quot;: &quot;launchStream&quot;, &quot;data&quot;: &quot;&quot; } } }, { &quot;name&quot;: &quot;rip&quot;, &quot;socketCall&quot;: { &quot;emit&quot;: &quot;callMethod&quot;, &quot;payload&quot;: { &quot;endpoint&quot;: &quot;music_service\/streaming_controller&quot;, &quot;method&quot;: &quot;updateStream&quot;, &quot;data&quot;: &quot;&quot; } } }, { &quot;name&quot;: &quot;eject&quot;, &quot;socketCall&quot;: { &quot;emit&quot;: &quot;callMethod&quot;, &quot;payload&quot;: { &quot;endpoint&quot;: &quot;music_service\/streaming_controller&quot;, &quot;method&quot;: &quot;refreshStream&quot;, &quot;data&quot;: &quot;&quot; } } } ]} Get Current Play Queue GetQueue The queue is a json object: [ { uri: 'NAS\/Flac\/Paolo Conte - 1984 - Paolo Conte [1995 Reissue]\/10 - Macaco.flac', service: 'mpd', name: 'Macaco', artist: 'Paolo Conte', album: 'Paolo Conte', type: 'track', tracknumber: '0', albumart: 'http:\/\/img2-ak.lst.fm\/i\/u\/300x300\/1b82dd5e54554209bf2326ffb76f6814.png' }, { uri: 'NAS\/Flac\/Paolo Conte - 1984 - Paolo Conte [1995 Reissue]\/01 - Sparring Partner.flac', service: 'mpd', name: 'Sparring partner', artist: 'Paolo Conte', album: 'Paolo Conte', type: 'track', tracknumber: '1', albumart: 'http:\/\/img2-ak.lst.fm\/i\/u\/300x300\/1b82dd5e54554209bf2326ffb76f6814.png' }] Remove Item from queue removeFromQueue N where N is the track number in the queue, 0 for the first, 9 for the tenth and so on Add Item to Queue addToQueue {'uri:uri'} where uri is the uri of the item we want to add If we want to add an individual track from a .cue file: addPlayCue {uri:'uriofsong',number:3} Playlist handling createPlaylist deletePlaylist {value:playlistname} listPlaylist addToPlaylist removeFromPlaylist playPlaylist enqueue createPlaylist This method creates a new playlist Input: { &quot;name&quot;:&quot;myplaylist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false deletePlaylist This method deletes a playlist Input: { &quot;name&quot;:&quot;myplaylist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false listPlaylist This method lists all playlists in the system Input: None Output (through event pushListPlaylist): [ &quot;playlistA&quot;, &quot;playlistB&quot;, ... ] The reason field is set only if success is false addToPlaylist This method adds a song to an existing playlist Input: { &quot;name&quot;:&quot;my playlist&quot;, &quot;service&quot;:&quot;mpd&quot;, &quot;uri&quot;:&quot;USB\/...&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false removeFromPlaylist This method removes all occurrences of a song from an existing playlist Input: { &quot;name&quot;:&quot;my playlist&quot;, &quot;uri&quot;:&quot;USB\/...&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false playPlaylist This method clears the queue, adds the playlist and play Input: { &quot;name&quot;:&quot;my playlist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false enqueue This method enqueue all songs of a playlist Input: { &quot;name&quot;:&quot;my playlist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false CallMethod on Plugin Each method of a plugin can be execute through a websocket call. As of now there's no ACL or any security feature but thi s will change in the future. To execute a method the following socket.io command shall be issued: callMethod The payload shall be a json with the following structure: { &quot;endpoint&quot;:&quot;category\/name&quot;, &quot;method&quot;:&quot;methodName&quot;, &quot;data&quot;: {} } where: endpoint is a string used to target the plugin. Its structure is a linux path like string containing the plugin category, a slash and the plugin name. An example: endpoint:'music_service\/spop'. method is a string containing the name of the method to be executed. data is a complex value (can be a string or a Json) and is passed as is to the method. IMPORTANT: There should be no &quot;-&quot; in this call, due to FE parsing method (it converts \/ to -). So plugins and functions should not contain &quot;-&quot;. Once the method returns, the result is pushed back to the client with the event 'pushMethod'. Miscellaneous Sleep &amp; Alarm Clock getSleep Triggers : pushSleep {enabled:true|false, time:hh:mm:} To set sleep mode: setSleep {enabled:true|false, time:hh:mm:} getAlarms Triggers: pushAlarms {[{id:1,enabled:true, time:hh:mm, playlist:uriplaylist},{id:2,enabled:true, time:hh:mm, playlist:uriplaylist}]} To add a new alarm: addAlarm {time:hh:mm, playlist:uriplaylist} When a new Playlist gets added, the Values enabled:true and id (as progressive numbering) are added by default by the Backend. To edit an alarm: setAlarm {id:1,enabled:true, time:hh:mm, playlist:uriplaylist} Those values will replace the values of the correspondent playlist id. To remove an alarm: removeAlarm {id:3}","tags":"","url":"API\/WebSocket_APIs.html"},{"title":"UI Configuration Pages","text":"Design Principles The main idea is to provide a mechanism to describe the configuration section of the UI and the configuration of plugins that is flexible and not bound to code. To reach this the whole hs to be described with an higher level language. Plugin\\Core component Configuration is composed of different parts: Configuration File Configurations reside on single .json files, pertaining to a core component or a specific plugin. Every core component that needs a configuration file (example: network controller, Network Mount Controller, Playback Settings) will have their json specific file into \/app\/config . If a controller has its own folder, the json config file will be placed in the same controller folder, along with the index.js file. The configuration will be handled by Convict and it will look this way: Each item is described as follows: &quot;KEY&quot;:{ &quot;value&quot;:&quot;VALUE&quot;, &quot;type&quot;:&quot;[boolean|int|string|password|ipaddress|page|section|select]&quot;, &quot;label&quot;:&quot;Blah blah&quot; } where: KEY [MANDATORY] identifies the item. VALUE [OPTINAL] this attribute contains the current item value. Its format depends on the type. For example a boolean type will contains true or false while a string type can contain any string. TYPE [MANDATORY] this attribute describes the data type. As of now the above values are supported. More can (and will) come in the future. DOC [MANDATORY] This attribute contains the label associated to the item, in the locale specified by the caller (Example for Wired Network Config File) var wirednetworkconf = convict({ dhcp: { doc: &quot;DHCP Configuration&quot;, format: [&quot;dhcp&quot;, &quot;static&quot;], default: &quot;dhcp&quot;, value: &quot;dhcp&quot; }, ip: { doc: &quot;Static IP Address &quot;, format: &quot;ipaddress&quot;, default: &quot;null&quot;, value: &quot;IP_ADDRESS&quot;, }, netmask: { doc: &quot;Netmask&quot;, format: &quot;ipaddress&quot;, default: 255.255.255.0, value: &quot;255.255.255.0&quot; }, gateway: { doc: &quot;Gateway&quot;, format: &quot;ipaddress&quot;, default: &quot;null&quot;, value: &quot; &quot; } }); Another example is SPOP's config file , the spotify daemon: var spopconf = convict({ spotify_username: { doc: &quot;Spotify Username&quot;, format: [&quot;*&quot;], default: &quot;null&quot;, env: &quot; &quot; }, spotify_username: { doc: &quot;Spotify Username&quot;, format: &quot;*&quot;, default: &quot;null&quot;, env: &quot; &quot;, }, high_bitrate: { doc: &quot;Prefer High Bitrate Streams&quot;, format: [&quot;true&quot;, &quot;false&quot;], default: &quot;true&quot;, env: &quot;true&quot; }, enabled: { doc: &quot;Enable Spotify Service&quot;, format: &quot;*&quot;, default: &quot;false&quot;, env: &quot;false&quot; }, }); Index File Each configuration will have in its parent index.js (the actual core component\\plugin file), among the others, methods that describes: Required Start If the Component\\ plugin needs a daemon or service to be up and running, it's invoke function must be present. start Required Re-Start If the Component\\ plugin needs a daemon or service to be restarted when its configuration changes, it's restart function must be present. restart Install A function that installs the required (if any) external packages. This can be a shell script, an apt package. It must perform the installation and report a Success message or an error message, with indication of what happened. A method for specific component function Example: if this is a sources plugin, which services are exposed and how to retrieve them. TO BE FURTHER DISCUSSED Display Section This will be invoked by the front end when the pertaining configuration page is to be shown. This function will appropriately parse and serve via the Socket Interface a &quot;layout&quot; of the pertaining configuration page. We'll use a standardized way to provide the UI with predefined layout elements and DOMs, that will be consistent across the whole Volumio frontend system. DOM COMPONENTS Initially we'll have only 2 DOM: Section: This will be used as containers for specific configurations inclusion. Page Title: speaks for itself Example: Network Configuration Page (name), will contain 2 sections: Wired And Wireless. ELEMENTS The elements are used just to manipulate the configuration in the most appropriate way. And their number will be finite. We're taking standard bootstrap naming and examples as reference, even if look and feel will be customized . Select Input (text or string) Save\\Discard Bar Progress Bar Selector Checkbox Radio Button Those configurations fields can be nested, and with DOM style element included, will represent a &quot;skeleton&quot; for the UI frontend to wrap and build accordingly. As a mere example, let's see how Wireless Configuration Page will look like (this is the emitted object via socket.io to the backend) : &quot;networkpage&quot;:{ &quot;title&quot;:&quot;Network Settings&quot; &quot;section&quot;:{ &quot;title&quot;:&quot;Wired Networking&quot;, &quot;label&quot;:&quot;Network configuration&quot;, &quot;children&quot;:{ &quot;wifi&quot;:{ &quot;value&quot;:&quot;true&quot;, &quot;type&quot;:&quot;boolean&quot;, &quot;label&quot;:&quot;Enable Wifi&quot; } } }, &quot;sub_page_b&quot;:{ &quot;type&quot;:&quot;page&quot;, &quot;label&quot;:&quot;System configuration&quot; &quot;children&quot;:{} }, } } ##Linking items in a hierarchy Items can be linked in a tree hierarchy. To do this the attribute children is specified. Its value is an object containig subitems. Below an example: &quot;main&quot;:{ &quot;type&quot;:&quot;page&quot;, &quot;label&quot;:&quot;Network Configuration&quot; &quot;children&quot;:{ &quot;type&quot;:&quot;section&quot;, &quot;label&quot;:&quot;Wired Network&quot;, &quot;children&quot;:{ &quot;dhcp&quot;:{ &quot;type&quot;:&quot;select&quot;, &quot;label&quot;:&quot;DHCP Network Settings&quot;, &quot;current_value&quot;:&quot;true&quot;, &quot;options&quot;:[{true: Automatic (DHCP)},{false:Static}], }, &quot;children&quot;:{ &quot;type&quot;:&quot;section&quot;, &quot;label&quot;:&quot;Static IP Configuration&quot;, &quot;visibleif&quot; &quot;dhcp:false&quot; \/\/show if dhcp is set to false :{ &quot;IP&quot;:{ &quot;type&quot;:&quot;text_box&quot;, &quot;value&quot;:&quot; &quot;, &quot;format&quot;:ipaddress, &quot;label&quot;:&quot;IP&quot; }, &quot;netmask&quot;:{ &quot;type&quot;:&quot;text_box&quot;, &quot;value&quot;:&quot; &quot;, &quot;format&quot;:ipaddress, &quot;label&quot;:&quot;Netmask&quot; }, &quot;gateway&quot;:{ &quot;type&quot;:&quot;text_box&quot;, &quot;value&quot;:&quot; &quot;, &quot;format&quot;:ipaddress, &quot;label&quot;:&quot;Gateway&quot; }, } } }, &quot;wireless_section&quot;:{ &quot;type&quot;:&quot;section&quot;, &quot;label&quot;:&quot;Wireless Network&quot;, }, } }","tags":"","url":"API\/UI_Configuration_Pages.html"},{"title":"REST API","text":"Playback commands All API calls will look like: volumio.local\/api\/v1\/commands\/?cmd= example: volumio.local\/api\/v1\/commands\/?cmd=play Available commands: Play volumio.local\/api\/v1\/commands\/?cmd=play&amp;N=2 where N is optional and is the ordinal number of the track in the queue you wish to start to play from. The above call will play the third track in the queue. Stop volumio.local\/api\/v1\/commands\/?cmd=stop Pause volumio.local\/api\/v1\/commands\/?cmd=pause Previous volumio.local\/api\/v1\/commands\/?cmd=prev Next volumio.local\/api\/v1\/commands\/?cmd=next Volume volumio.local\/api\/v1\/commands\/?cmd=volume&amp;volume=80 where volume can be: mute, unmute, plus, minus (plus and minus will increase\\decrease as per parameter one click volume steps) Music Library Clear the queue volumio.local\/api\/v1\/commands\/?cmd=clearQueue List Playlists volumio.local\/api\/v1\/listplaylists Play a Playlist volumio.local\/api\/v1\/commands\/?cmd=playplaylist&amp;name=Rock where name is the name of the playlist to play Backup This is the generic command to retrieve a json with the playlist selected in type. Allowed types are: &quot;playlist&quot; replies with custom playlists, sorted by their names. &quot;favourites&quot; replies with the playlist of favorites songs. &quot;radio-favourites&quot; replies with the playlist of favorites radios. &quot;my-web-radio&quot; replies with the playlist of custom radios. volumio.local\/api\/v1\/backup\/playlists\/:type Reply: [ { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=893796&quot;, &quot;title&quot;: &quot;Dance Wave!&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=832669&quot;, &quot;title&quot;: &quot;Radio Sobsomoy&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=862132&quot;, &quot;title&quot;: &quot;ANTENA1 - 94 7 FM&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=344030&quot;, &quot;title&quot;: &quot;U1 Tirol&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; } ] This is an example of volumio.local\/api\/v1\/backup\/playlists\/radio-favourites. This is the generic command to retrieve a json with the configurations of every plugin, with their status, sorted by category. volumio.local\/api\/v1\/backup\/config\/ Reply: [ { &quot;cName&quot;: &quot;system_controller&quot;, &quot;plugConf&quot;: [ { &quot;name&quot;: &quot;updater_comm&quot;, &quot;status&quot;: true, &quot;config&quot;: &quot;&quot; }, { &quot;name&quot;: &quot;network&quot;, &quot;status&quot;: true, &quot;config&quot;: { &quot;dhcp&quot;: { &quot;value&quot;: true, &quot;type&quot;: &quot;boolean&quot; }, &quot;ethip&quot;: { &quot;value&quot;: &quot;127.0.0.1&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;ethnetmask&quot;: { &quot;value&quot;: &quot;255.255.255.0&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;ethgateway&quot;: { &quot;value&quot;: &quot;0.0.0.0&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;wlanssid&quot;: { &quot;value&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;wlanpass&quot;: { &quot;value&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; } } }, { &quot;name&quot;: &quot;networkfs&quot;, &quot;status&quot;: true, &quot;config&quot;: { &quot;NasMounts&quot;: { &quot;53b83b5a-dccf-4d2f-800e-96fdc5dc4eb1&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;FLAC&quot; }, &quot;ip&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;DISKSTATION&quot; }, &quot;path&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;FLAC&quot; }, &quot;fstype&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;cifs&quot; }, &quot;user&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;password&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;options&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; } } } } } This is the generic command to restore a playlist: volumio.local\/api\/v1\/restore\/playlists You have to specify, as POST fields: type: playlist songs radios myRadios path: favourites radio-favourites my-web-radio data Type is the kind of data you're sending, path is required for default playlists, to name the correspondent file (since for custom playlists the file will be named after the name found in data), data is a json containing informations properly formatted. This is the generic command to restore configuration files: volumio.local\/api\/v1\/restore\/config You have to specify a POST field named config, that has to contain an array of JSON object with plugins and correspondent configurations, sorted by category.","tags":"","url":"API\/REST_API.html"},{"title":"Plugin System Overview","text":"Introduction Volumio2 introduces the concept of plugins to expand its functionality, and allow an easy sharing of the tweaks and improvements usually generated by the community. We've worked hard to create a standardized layout to make it easier to develop any kind of plugin. If you feel that your particular use case is not covered, please open an issue or discussion at the plugins repo: https:\/\/github.com\/volumio\/volumio-plugins What is plugin ? A plugin is meant to add one specific functionality. It is provided as zip file which contains all needed files for it to work, either directly included in the zip file or available via a an install script that will download them autoatically. Plugins can be installed via Volumio's UI, by selecting the &quot;Plugins&quot; menu entry. From there you will be able to browse the Online Plugin Repository, or upload a plugin .zip file from your disk if not in the list. Plugins are located under \/data\/plugins\/ And they are organized in subfolder per categories. When installing plugin, a folder is created in: \/data\/plugins\/mycategory\/myplugins All plugins related files (extracted from zip and resulting from install sh script will be found here). Existing Plugin Categories PLEASE NOTE: Categories name must be lowercase and separated by _ . audio_interface This typically collects plugins that add an audio interface, aka an external and not browsable music source. Typical examples are: Airplay UpNp Bluetooth music_service Those are browsable music sources, typically: MPD (for local files) Webradios Directories Streaming Services like Spotify miscellanea Those plugins that are too general purpose to classify. Furthermore they are meant to work as standalone units, and they don't require interaction with other plugins. Examples: Appearance Plugins system_controller Those are usually core-plugins, meant to handle vital parts of Volumio. Networking Network Attached Storage Core updater services user_interface Those plugins are meant to allow external communication to Volumio. Developing a new one will be useful to add API Rest Capability, or to extend Volumio interoperability with third party apps and controllers. Some examples: MPD Client Protocol emulation Squeeze Box emulation Phisical button controller What features can be added This features could be miscellaneous, such as new online music provider, new radio stream, management of the GPIO (for supported devices), various DSP, display and plenty of other useful things ! The only limitation is your imagination ! A good way to understand how is made a plugin, is to browse \/volumio\/app\/plugins folder and \/data\/plugins folder. You\u00e2\u0080\u0099ll find inspiration for your own dev ! Plugin Configuration files While first start, Volumio will create a folder that contains saved parameter in a config.json stored in: \/data\/configuration\/mycategory\/myplugins The plugins.json file The plugins.json file stores the status of core (found in \/volumio\/app\/plugins\/plugins.json folder) and extra (found in \/data\/plugins\/plugins.json ) plugins. IMPORTANT : If you create a new plugin MANUALLY, you MUST add a plugin reference to plugins.json files (in \/data\/plugins\/plugins.json). If such reference is not found, volumio will automatically delete your plugin folder. The plugins json contains informations on plugins status: Enabled, which can be true or false Started, which can be true or false Add your information under your plugin relevant category. For example, if I'm adding a music_service plugin called &quot;google_music&quot;, the relevant section will look like { &quot;music_service&quot;: { &quot;google_music&quot;: { &quot;enabled&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;value&quot;: true }, &quot;status&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;STARTED&quot; } }, ...","tags":"","url":"Plugin_System\/Plugin_System_Overview.html"},{"title":"Writing A Plugin","text":"The Plugin Zip File The plugin zip file will be created as the last step of the plugin creation and it must contains : Mandatory Files Name Format Content install.sh Bash script this file contains a script of action and dependencies installation needed for the plugin. It\u00e2\u0080\u0099s a BASH script. It MUST be executable. index.js javascript this is main file, written in node.js node_modules folder folder that contains all node modules needed config.json json this file contains all the parameters to be save for the plugin. Package.json json this file contains description of the plugin and the list of required node dependencies Uninstall.sh Bash script this file contains the script to remove the plugin. Details and examples of mandatories files. Here you will find more details for each files listed above, what they contain, how to write a working plugin. Examples based on Spop plugin. Install.sh This file allows download and installation of dependencies for the plugin. It\u00e2\u0080\u0099s a executable file written in BASH. #!\/bin\/bash echo &quot;Installing Spop Dependencies&quot; sudo apt-get update sudo apt-get -y install libasound2-dev libreadline-dev libsox-dev libsoup2.4-dev libsoup2.4-1 libdbus-glib-1-dev libnotify-dev --no-install-recommends echo &quot;Installing Spop and libspotify&quot; DPKG_ARCH=`dpkg --print-architecture` echo $DPKG_ARCH cd \/tmp wget http:\/\/repo.volumio.org\/Packages\/Spop\/spop-${DPKG_ARCH}.tar.gz sudo tar xvf \/tmp\/spop-${DPKG_ARCH}.tar.gz -C \/ rm \/tmp\/spop-${DPKG_ARCH}.tar.gz sudo chmod 777 \/etc\/spopd.conf #required to end the plugin install echo &quot;plugininstallend&quot; IMPORTANT THINGS TO NOTICE Use &quot;echo&quot; to detail what's going during the install, this will help you debugging, and notify the user what goes on during install Since we are installing compiled binaries (that need to be compiled for both x86 and armhf, using dpkg --print-architecture as part of the file name will ensure an architecture-agnostic script) For security reasons dpkg is not allowed, so if you need to install binaries, tar them and download the tar accordingly We have no environment variable set, so make sure you cd in the desired folder Ensure to give proper permissions to file you'll need to edit later on (node runs with user volumio) To avoid installing unwanted stuff, make sure to place --no-install-recommends after your to-install list echo &quot;plugininstallend&quot; must be placed at the end of the install script to signal that installation has ended. Index.js Index.js This file is the main file of the plugin. It is written in javascript. Please refer to index.js section for a detailed explanation. config.json File in which is saved default parameters, and the way saved parameters will be saved. { &quot;enabled&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;value&quot;: false }, &quot;username&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;password&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;bitrate&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;value&quot;: true } } package.json This file contains package description and dependencies { &quot;name&quot;: &quot;spop&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Spotify plugin for Volumio2&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;volumio_info&quot;: { &quot;prettyName&quot;: &quot;Spotify&quot;, &quot;icon&quot;: &quot;fa-spotify&quot;, &quot;plugin_type&quot;: &quot;music_service&quot;, &quot;boot_priority&quot;:1 }, &quot;dependencies&quot;: { &quot;fast.js&quot;: &quot;^0.1.1&quot;, &quot;fs-extra&quot;: &quot;^0.28.0&quot;, &quot;kew&quot;: &quot;^0.7.0&quot;, &quot;net&quot;: &quot;^1.0.2&quot;, &quot;nodetools&quot;: &quot;^1.0.0&quot;, &quot;spotify-web-api-node&quot;: &quot;^2.3.0&quot;, &quot;v-conf&quot;: &quot;^0.10.0&quot; } } IMPORTANT THINGS TO NOTICE The relevant parts are: name: this will be the plugin's name folder licence: use any licence, you're not bound to GPL here dependencies: indicate the node modules this plugin requres, to avoid yourself the extra hassle of 2 different zip files for x86 and ARM, try to choose node modules that don't need to be compiled or rely on external dependencies make sure to indicate propery the pretty name, icon and plugin type. The more straightforward, the better version, this is used to keep track of version and request for updates if new versions are found boot priority, accepts a numerical value from 1 to 10. Useful if you need to start your plugin after one another. 1 means it is started first, 10 means it will be started at last. Uninstall.sh Bash file. As install file MUST be executable. Here you will basically revert what you did in the install.sh file . Name Format Content i18n folder contains string_en.json and other strings to translate the plugin Uiconfig.json json this file describe the UI of the plugin. Other Text, image, sound, script, executable... required file \/ script to use in the plugin such as executable or service,image, sound, application key... RequiredConf.json json Configuration key or variables mandatory for the plugin to work. Useful to add a new parameter with an update Details and examples of optional files Depending on the plugin, other file may be nedeed. Uiconfig.json This file describes the user interface for the plugin configuration, that will appear while clicking on the cog. Please refer to UI Configuration Pages for reference. I18n This folder contains languages strings if you want to translate your plugin You have to have one file per language. The file naming is \u00e2\u0080\u009cstrings_en.json\u00e2\u0080\u009d for english. Of course replace \u00e2\u0080\u009cen\u00e2\u0080\u009d by the language to be translated \u00e2\u0080\u009cit\u00e2\u0080\u009d, \u00e2\u0080\u009cfr\u00e2\u0080\u009d, \u00e2\u0080\u009ces\u00e2\u0080\u009d. This is a json file. { &quot;spotify_username&quot;:&quot;Spotify username&quot;, &quot;spotify_password&quot;:&quot;Spotify password&quot;, &quot;high_bitrate&quot;:&quot;High quality&quot;, &quot;search_results&quot;:&quot;Number of results&quot;, &quot;plugins&quot;:&quot;Last.fm&quot;, &quot;last_fm_username&quot;:&quot;Last.fm username&quot;, &quot;last_fm_password&quot;:&quot;Last.fm password&quot;, &quot;SEARCH_SONGS_SECTION&quot;:&quot;Spotify songs&quot;, &quot;SEARCH_ALBUMS_SECTION&quot;:&quot;Spotity albums&quot;, &quot;SEARCH_ARTISTS_SECTION&quot;:&quot;Spotify artists&quot; } Other Your plugin may require other files such as image, sound, executable, configuration files etc\u00e2\u0080\u00a6 You have to include these files in the ZIP file and ensure proper permissions if they'll need to be edited.","tags":"","url":"Plugin_System\/Writing_A_Plugin.html"},{"title":"Index.js","text":"Index.js aka the plugin's core The index.js file of every plugin is where the magic goes on. It has some predefined and mandatory functions and a standardized layout. Depending on you'r plugin's category, this structure needs to change accordingly. We'll start by detailing a generic plugin structure. Generic structure The first part is about module dependencies, we'll need to list all the node modules our plugin depends on (example taken from Spotify plugin). 'use strict'; var libQ = require('kew'); var libNet = require('net'); var libFast = require('fast.js'); var fs=require('fs-extra'); var config = new (require('v-conf'))(); var exec = require('child_process').exec; var SpotifyWebApi = require('spotify-web-api-node'); var nodetools = require('nodetools'); IMPORTANT TIPS: Node modules allow you to develop faster, by relaying on already-written code to overcome the majority of tasks, to look for them search here The 'use strict'; declaration at the beginning will ensure no obvious coding mispractices will happen, more info on the matter Use the minimum amount of modules needed, and try to avoid modules that needs compilation (you will spot those because they'll take longer on npm install), so you will avoid to mantain two separate versions for x86 and arm architectures. Then we will define the plugin class and reference to other core Volumio's internals: module.exports = ControllerSpop; function ControllerSpop(context) { \/\/ This fixed variable will let us refer to 'this' object at deeper scopes var self = this; this.context = context; this.commandRouter = this.context.coreCommand; this.logger = this.context.logger; this.configManager = this.context.configManager; } IMPORTANT TIPS: Substitute ControllerSpop with something that resembles your plugin name. For example ControllerGPIO or ControllerSoundcloud We'll start every prototype (see later) with this Controller naming Then we add all the required functions for a generic plugin: On Volumio Start This is the code that gets executed when Volumio starts and triggers the plugin start. Typically, what you do is load the plugin configuration. ControllerSpop.prototype.onVolumioStart = function() { var configFile=this.commandRouter.pluginManager.getConfigurationFile(this.context,'config.json'); this.config = new (require('v-conf'))(); this.config.loadFile(configFile); } On Start This instead is what happens when the Plugin starts. It's different from On Volumio Start since this function is triggered only if the plugin is enabled. In this case we're starting the spop daemon (responsible for Spotify Playback). ControllerSpop.prototype.onStart = function() { var self = this; var defer=libQ.defer(); self.startSpopDaemon() .then(function(e) { setTimeout(function () { self.logger.info(&quot;Connecting to daemon&quot;); self.spopDaemonConnect(defer); }, 5000); }) .fail(function(e) { defer.reject(new Error()); }); this.commandRouter.sharedVars.registerCallback('alsa.outputdevice', this.rebuildSPOPDAndRestartDaemon.bind(this)); return defer.promise; }; IMPORTANT: You'll notice that we use promises here. That's why Volumio needs to know when the plugin has actually started, or if it failed. So what we're doing is returning the promise on successful start, and rejecting it if it doesn't start properly. The strange function this.commandRouter.sharedVars.registerCallback('alsa.outputdevice', this.rebuildSPOPDAndRestartDaemon.bind(this)); does one important thing. It binds to a shared system value (alsa.outputdevice, which is the output device) and when it changes it triggers the function rebuildSPOPDAndRestartDaemon that rewrites spop config file and restarts it. On stop When a plugin is stopped, this function gets executed. What we're doing here is killing the spop daemon. We must resolve the promise to signal everything was ok ControllerSpop.prototype.onStop = function() { var self = this; self.logger.info(&quot;Killing SpopD daemon&quot;); exec(&quot;\/usr\/bin\/sudo \/usr\/bin\/killall spopd&quot;, function (error, stdout, stderr) { if(error){ self.logger.info('Cannot kill spop Daemon') } }); return libQ.resolve(); }; Get Configuration files Very straightforwarding, we load the .json configuration file for this plugin. ControllerSpop.prototype.getConfigurationFiles = function() { return ['config.json']; } Get UI configuration This function is triggered when we want to access the plugin configuration. For a better understanding of the configuration pages see Configuration Pages ControllerSpop.prototype.getUIConfig = function() { var defer = libQ.defer(); var self = this; var lang_code = this.commandRouter.sharedVars.get('language_code'); self.commandRouter.i18nJson(__dirname+'\/i18n\/strings_'+lang_code+'.json', __dirname+'\/i18n\/strings_en.json', __dirname + '\/UIConfig.json') .then(function(uiconf) { uiconf.sections[0].content[0].value = self.config.get('username'); uiconf.sections[0].content[1].value = self.config.get('password'); uiconf.sections[0].content[2].value = self.config.get('bitrate'); defer.resolve(uiconf); }) .fail(function() { defer.reject(new Error()); }); return defer.promise; }; IMPORTANT: With var lang_code = this.commandRouter.sharedVars.get('language_code'); we retrieve the current language code. If translation is provided under the \/i18n\/ folder, we'll translate the configuration page, if not we'll default to english. We use promises here as well, since it will take some time to parse the UIConfig.json and translate it. Not using promises will result in configuration not working. With uiconf.sections[0].content[0].value = self.config.get('username'); we're simply subsituting the first element's value of the first section with the username value taken from the plugins configuration. That's how we can populate the UI Configuration Page with actual values. Optional functions for generic plugins Get configuration from other plugins There are cases where we want to get configuration parameters from other plugins, for example to know if an i2s DAC has been enabled or not. We will then use the executeOnPlugin method which will allow us to execute any method on any plugin. For code clarity we wrapped it into the getAdditionalConf function, accepting 3 parameters which are mandatory for the aforementioned executeOnPlugin: TYPE (plugin category) CONTROLLER (plugin name) DATA (the configuration parameter we want to get) Please note that the function to get config parameters is not always getConfigParam but could be also just getConf. Check the individual plugin to see which is the correct function. ControllerAlsa.prototype.getAdditionalConf = function (type, controller, data) { var self = this; return self.commandRouter.executeOnPlugin(type, controller, 'getConfigParam', data); }; Set configuration from other plugins Same as above, also here setConfigParamcould be also setConf or setUiConfig. Check the individual plugin to see which is the correct function. UpnpInterface.prototype.setAdditionalConf = function () { var self = this; return self.commandRouter.executeOnPlugin(type, controller, 'setConfigParam', data); }; Restart Sometimes it might be useful to have a function to restart the plugin. Here's an example for upnp interface in Volumio. UpnpInterface.prototype.onRestart = function () { var self = this; exec('\/usr\/bin\/sudo \/usr\/bin\/killall upmpdcli', function (error, stdout, stderr) { if (error) { self.logger.error('Cannot kill upmpdcli '+error); } self.startUpmpdcli(); }); }; Mandatory Functions for Music Sources Plugin Music sources requires an extra bit of functions to be hooked properly into Volumio. Basically the need to expose their &quot;browsable&quot; structure of data, allow search and provide a translation for their displayed name on Music Sources. Missing any of those will result in a non working plugin, and possibly a broken Volumio. Those are: addToBrowseSources handleBrowseUri explodeUri search Add to Browse sources This functions adds the new music source to Main Browse Menu. Rules to Follow: Invoke this function ONLY when the plugin starts properly, and if you're relying on a daemon only when successful connection has been established with the daemon and the service. Every call to the uri specified here, will be handled by this plugin. Basically, when clicking &quot;Spotify&quot;, we'll handle the request in this plugin via the function and return the sub-categories available. Those will be handled by the handleBrowseUri function later on. ControllerSpop.prototype.addToBrowseSources = function () { var data = {name: 'Spotify', uri: 'spotify',plugin_type:'music_service',plugin_name:'spop'}; this.commandRouter.volumioAddToBrowseSources(data); }; Handle Browse uri This function is responsible to interpret the desired URI (basically the browse point requested) and return the available items. Some examples: Webradios browsing: ControllerWebradio.prototype.handleBrowseUri=function(curUri) { var self=this; var response; if (curUri.startsWith('radio')) { if (curUri == 'radio') response = self.listRoot(curUri); else { if (curUri.startsWith('radio\/myWebRadio')) { response = self.listMyWebRadio(curUri); } if (curUri.startsWith('radio\/byGenre')) { if (curUri == 'radio\/byGenre') response = self.listRadioGenres(curUri); else response = self.listRadioForGenres(curUri); } if (curUri.startsWith('radio\/favourites')) { response = self.listRadioFavourites(curUri); } if (curUri==='radio\/top500') { response = self.listTop500Radios(curUri); } else if (curUri.startsWith('radio\/byCountry')) { if (curUri == 'radio\/byCountry') response = self.listRadioCountries(curUri); else response = self.listRadioForCountry(curUri); } } } return response; } Music Library and playlist browsing: ControllerMpd.prototype.handleBrowseUri = function (curUri) { var self = this; var response; if (curUri.startsWith('music-library')) { response = self.lsInfo(curUri); }else if (curUri.startsWith('playlists')) { if (curUri == 'playlists') response = self.listPlaylists(curUri); else response = self.browsePlaylist(curUri); } return response; }; Spotify browsing ControllerSpop.prototype.handleBrowseUri=function(curUri) { var self=this; \/\/self.commandRouter.logger.info(curUri); var response; if (curUri.startsWith('spotify')) { if(curUri=='spotify') { response=libQ.resolve({ navigation: { prev: { uri: 'spotify' }, lists: [ { &quot;title&quot;: &quot;Spotify Folders&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;availableListViews&quot;: [&quot;list&quot;,&quot;grid&quot;], &quot;items&quot;: [ { service: 'spop', type: 'folder', title: 'My Playlists', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/playlists' }, { service: 'spop', type: 'folder', title: 'Featured Playlists', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/featuredplaylists' }, { service: 'spop', type: 'folder', title: 'What\\'s New', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/new' }, { service: 'spop', type: 'folder', title: 'Genres &amp; Moods', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/categories' } ] } ] } }); } else if(curUri.startsWith('spotify\/playlists')) { if(curUri=='spotify\/playlists') response=self.listPlaylists(); else { response=self.listPlaylist(curUri); } } else if(curUri.startsWith('spotify\/featuredplaylists')) { response=self.featuredPlaylists(curUri); } else if(curUri.startsWith('spotify\/webplaylist')) { response=self.listWebPlaylist(curUri); } else if(curUri.startsWith('spotify\/new')) { response=self.listWebNew(curUri); } else if(curUri.startsWith('spotify\/categories')) { response=self.listWebCategories(curUri); } else if(curUri.startsWith('spotify\/album')) { response=self.listWebAlbum(curUri); } else if(curUri.startsWith('spotify\/category')) { response=self.listWebCategory(curUri); } else if(curUri.startsWith('spotify:artist:')) { response=self.listWebArtist(curUri); } } return response; }; BEST PRACTICES: Hardcode all expected uris, and handle errors in case you receive an unknown one Use separate functions for every uri tpye Use promises where possible If you use an external API service with API limits, cache where possible. Navigation is nested, so make sure you provide the upper level (needed for going back while browsing) You can display an icon by using icon and using a font-awesome icon You can display an image by using albumart, you can then pass a direct url or use the Albumart Server The albumart API is: \/albumart?web=artist\/album\/large&amp;path=path all encoded which becomes \/albumart?web=Alabama%20Shakes\/Sound%20%26%20Color\/large&amp;path=%2FUSB%2FALABAMA%20SHAKES%20S%20%26%20C The title and icon attributes are used to divide sections with different content in it, like showing albums and songs for a particular artists. They become separators. The availableListViews attribute is used to indicate the visualizations options available for this particular list of items. Generally folders, albums and artists have both list and grid views available, while tracks and genres are visualized only in list mode. GENERIC OUTPUT EXAMPLE: { &quot;navigation&quot;: { &quot;lists&quot;: [ { &quot;title&quot;: &quot;Artists&quot;, &quot;icon&quot;: &quot;fa icon&quot;, &quot;availableListViews&quot;: [ &quot;list&quot;, &quot;grid&quot; ], &quot;items&quot;: [ { &quot;service&quot;: &quot;mpd&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Led Zeppelin&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;uri&quot;: &quot;search:\/\/artist\/Led Zeppelin&quot; } ] }, { &quot;title&quot;: &quot;Webradios&quot;, &quot;icon&quot;: &quot;&quot;, &quot;availableListViews&quot;: [ &quot;list&quot; ], &quot;items&quot;: [ { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;ledjam&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=492072&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;NAXI 80-e RADIO (NAXI,Belgrade,Serbia, NAXI,Beograd,Srbija) - 128k&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=68544&quot; } ] } ], &quot;prev&quot;: { &quot;uri&quot;: &quot;\/&quot; } } } EXPECTED RESULTS EXAMPLES: Local folders { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;music-library&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;,&quot;grid&quot;], &quot;items&quot;: [ { &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;Calibro 35 (2008)&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;music-library\/USB\/Calibro 35 (2008)&quot; }, { &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;In Sight&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;music-library\/USB\/In Sight&quot; } ] } ] } } Local files { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;music-library\/USB&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;mpd&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Sound &amp; Color&quot;, &quot;artist&quot;: &quot;Alabama Shakes&quot;, &quot;album&quot;: &quot;Sound &amp; Color&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;uri&quot;: &quot;music-library\/USB\/ALABAMA SHAKES S &amp; C\/01 Sound &amp; Color.mp3&quot; }, { &quot;service&quot;: &quot;mpd&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Don't Wanna Fight&quot;, &quot;artist&quot;: &quot;Alabama Shakes&quot;, &quot;album&quot;: &quot;Sound &amp; Color&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;uri&quot;: &quot;music-library\/USB\/ALABAMA SHAKES S &amp; C\/02 Don't Wanna Fight.mp3&quot; } ] } ] } } Webradios { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;radio\/byGenre&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;Oldies FM&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=728640&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;San Francisco's 70's HITS!&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=1087995&quot; } ] } ] } } Spotify Categories (similar to local folders) { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;spotify&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;,&quot;grid&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;My Playlists&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;spotify\/playlists&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;Featured Playlists&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;spotify\/featuredplaylists&quot; } ] } ] } } Spotify Songs (streaming plugins) { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;spotify&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Vienna&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:5cgSWdlxIelg5N9OjfkRow&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;40 Beers&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:2r6oZ0GBqJaCnqqR72yiFc&quot; } ] } ] } } Explode uri This function takes care of retrieving all informations related to a particular URI, it's needed both by queue and state machine. Some examples: Local files (MPD) ControllerMpd.prototype.explodeUri = function(uri) { var self = this; var defer=libQ.defer(); var items = []; var cmd = libMpd.cmd; if(uri.startsWith('search:\/\/')) { \/\/exploding search var splitted=uri.split('\/'); var argument=splitted[2]; var value=splitted[3]; if(argument==='artist') { var commandArtist = 'search artist '+' &quot;' + value + '&quot;'; self.mpdReady.then(function () { self.clientMpd.sendCommand(cmd(commandArtist, []), function (err, msg) { var subList=[]; if (msg) { var lines = msg.split('\\n'); for (var i = 0; i &lt; lines.length; i++) { var line = lines[i]; if (line.startsWith('file:')) { var path = line.slice(5).trimLeft(); var name = path.split('\/'); var count = name.length; var artist = self.searchFor(lines, i + 1, 'Artist:'); var album = self.searchFor(lines, i + 1, 'Album:'); var title = self.searchFor(lines, i + 1, 'Title:'); var time = parseInt(self.searchFor(lines, i + 1, 'Time:')); if (title) { title = title; } else { title = name; } items.push({ uri: 'music-library\/'+path, service: 'mpd', name: title, artist: artist, album: album, type: 'track', tracknumber: 0, albumart: self.getAlbumArt({artist:artist,album: album},uri), duration: time, trackType: 'mp3' }); } } defer.resolve(items); } else if(err) defer.reject(new Error('Artist:' +err)); else defer.resolve(items); }); }); } else if(argument==='album') { var commandAlbum = 'search album '+' &quot;' + value + '&quot;'; self.mpdReady.then(function () { self.clientMpd.sendCommand(cmd(commandAlbum, []), function (err, msg) { var subList=[]; if (msg) { var lines = msg.split('\\n'); for (var i = 0; i &lt; lines.length; i++) { var line = lines[i]; if (line.startsWith('file:')) { var path = line.slice(5).trimLeft(); var name = path.split('\/'); var count = name.length; var artist = self.searchFor(lines, i + 1, 'Artist:'); var album = self.searchFor(lines, i + 1, 'Album:'); var title = self.searchFor(lines, i + 1, 'Title:'); var time = parseInt(self.searchFor(lines, i + 1, 'Time:')); if (title) { title = title; } else { title = name; } items.push({ uri: 'music-library\/' + path, service: 'mpd', name: title, artist: artist, album: album, type: 'track', tracknumber: 0, albumart: self.getAlbumArt({artist: artist, album: album}, uri), duration: time, trackType: 'mp3' }); } } defer.resolve(items); } else if(err) defer.reject(new Error('Artist:' +err)); else defer.resolve(items); }); }); } else defer.reject(new Error()); } else { var uriPath='\/mnt\/'+self.sanitizeUri(uri); self.commandRouter.logger.info('----------------------------'+uriPath); var uris=self.scanFolder(uriPath); var response=[]; libQ.all(uris) .then(function(result) { for(var j in result) { self.commandRouter.logger.info(&quot;-----&gt;&gt;&gt;&gt;&gt; &quot;+JSON.stringify(result[j])); if(result!==undefined &amp;&amp; result[j].uri!==undefined) { response.push({ uri: self.fromPathToUri(result[j].uri), service: 'mpd', name: result[j].name, artist: result[j].artist, album: result[j].album, type: 'track', tracknumber: result[j].tracknumber, albumart: result[j].albumart, duration: result[j].duration, samplerate: result[j].samplerate, bitdepth: result[j].bitdepth, trackType: result[j].trackType }); } } defer.resolve(response); }).fail(function(err) { self.commandRouter.logger.info(&quot;explodeURI: ERROR &quot;+err); defer.resolve([]); }); } return defer.promise; }; Webradio ControllerWebradio.prototype.explodeUri = function(uri) { var self = this; var defer=libQ.defer(); defer.resolve({ uri: uri, service: 'webradio', name: uri, type: 'track' }); return defer.promise; }; Search Every Music Service should provide a search function, but that's not mandatory. A typical search function MUST use promises and return objects formatted exactly like the above browse results. This is what a search backbone look like, where all search results are pushed into a list array and then resolved. Remember to divide search results (like artist, folders etc) with the APIs detailed above (title and icon) and to respect visualization types. ControllerSpop.prototype.search = function (query) { var self=this; var defer=libQ.defer(); defer.resolve(list); }, function (err) { self.logger.info('An error occurred while searching ' + err); }); }); return defer.promise;","tags":"","url":"Plugin_System\/Index.js.html"},{"title":"UI Configuration Pages","text":"The Configuration Pages To allow an easy development of plugin, we need a structured but still flexible way to configure plugins. Volumio uses a json based markup languages to describe the visual and functional aspects of configuration pages. This supports multilanguage and should be flexible enough to allow any kind of setting to be modified. If you feel your case is not covered, feel free to open an issue or discussion at https:\/\/github.com\/volumio\/Volumio2\/ Introduction Configurations resides on single .json files, pertaining to a core component or a specific plugin. This file is UIConfig.json and it's interpreted by the getUIConfig function present in every plugin. The very same system is used by both Volumio core plugins and community developed plugins, the only difference is that for core functions (such as Wi-fi browser, NAS Browser and some others) we developed special controllers in the UI. You can take a look at them in the core elements part of Volumio2 UI . This the flow of events that results in the visualization of the configuration page: Click on cog wheel, this sends the message getUiConfig for the category and plugin name CommandRouter forwards it to the Plugins The Plugin executes the getUIConfig function which parses and handles the UIConfig.json file Once this is done, it returns the full config, which is a json based object. UI parses it and visualizes it Upon saving, data is sent back as an object The UIConfig.json file It's the json file which describes visually and functionally the configuration page. A very simple example is spotify's plugin config file: { &quot;page&quot;: { &quot;label&quot;: &quot;Spotify Configuration&quot; }, &quot;sections&quot;: [ { &quot;id&quot;: &quot;section_account&quot;, &quot;element&quot;: &quot;section&quot;, &quot;label&quot;: &quot;Spotify account&quot;, &quot;icon&quot;: &quot;fa-plug&quot;, &quot;onSave&quot;: {&quot;type&quot;:&quot;controller&quot;, &quot;endpoint&quot;:&quot;music_service\/spop&quot;, &quot;method&quot;:&quot;saveSpotifyAccount&quot;}, &quot;saveButton&quot;: { &quot;label&quot;: &quot;Save&quot;, &quot;data&quot;: [ &quot;username&quot;, &quot;password&quot;, &quot;bitrate&quot; ] }, &quot;content&quot;: [ { &quot;id&quot;: &quot;username&quot;, &quot;type&quot;:&quot;text&quot;, &quot;element&quot;: &quot;input&quot;, &quot;doc&quot;: &quot;This is the username of your Spotify account&quot;, &quot;label&quot;: &quot;Username&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;id&quot;: &quot;password&quot;, &quot;type&quot;:&quot;password&quot;, &quot;element&quot;: &quot;input&quot;, &quot;doc&quot;: &quot;This is the password of your Spotify account&quot;, &quot;label&quot;: &quot;Password&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;id&quot;:&quot;bitrate&quot;, &quot;element&quot;: &quot;switch&quot;, &quot;doc&quot;: &quot;High bitrate&quot;, &quot;label&quot;: &quot;Set for high bitrate&quot;, &quot;value&quot;: true } ] } ] } Let's break it down and analyze in its sections: &quot;page&quot;: { &quot;label&quot;: &quot;Spotify Configuration&quot; } This is the Page's tite. &quot;sections&quot;: [ { &quot;id&quot;: &quot;section_account&quot;, &quot;element&quot;: &quot;section&quot;, &quot;label&quot;: &quot;Spotify account&quot;, &quot;icon&quot;: &quot;fa-plug&quot;, &quot;onSave&quot;: {&quot;type&quot;:&quot;controller&quot;, &quot;endpoint&quot;:&quot;music_service\/spop&quot;, &quot;method&quot;:&quot;saveSpotifyAccount&quot;}, &quot;saveButton&quot;: { &quot;label&quot;: &quot;Save&quot;, &quot;data&quot;: [ &quot;username&quot;, &quot;password&quot;, &quot;bitrate&quot; ] } Those are the sections descriptors. A section is typically a block of options which are related one to each other. Each section has: id : used to identify it element: the type, which is of course section label: the title of the section icon: the icon showed, it's a font-awesome icon onSave: it's the function invoked in the plugin index.js file, the payload will be a json object (see saveButton data item) saveButton label : pretty self-explanatory saveButton data : this will be the payload sent along, taking data from the elements into the array. In the case above the payload will be {&quot;username&quot;:usernameset,&quot;password&quot;:passwordset,&quot;bitrate&quot;:bitratedata} &quot;content&quot;: [ { &quot;id&quot;: &quot;username&quot;, &quot;type&quot;:&quot;text&quot;, &quot;element&quot;: &quot;input&quot;, &quot;doc&quot;: &quot;This is the username of your Spotify account&quot;, &quot;label&quot;: &quot;Username&quot;, &quot;value&quot;: &quot;&quot; } Content defines all the elements available in a section. It needs the following fields: id : the id, this one is the one referred in saveButton data type : type of the element, for a comprehensive list of examples see later doc : an explanation of what the field does label: label value: this is the current value of the element, can be manipulated in the getUIConfig function. It can be either a boolean (true | false), a string or a number. Optionally, you can also require a confirmation popup by adding the entry 'askForConfirm': {'title': 'Confirm', 'message': 'Do you want to save this values?'} If you want to hide or show an element dynamically based on the state on another option (in the same section), you can use 'visibleIf': {'field': 'spotify_service', 'value': true} Element Types Text input 'id': 'playerName', 'element': 'input', 'type': 'text', 'label': 'Player Name', 'attributes': [ {'placeholder': 'call me with a fancy name'}, {'maxlength': 10} ], 'value': 'Volumio' switch 'id': 'airplay', 'element': 'switch', 'label': 'Airplay', 'description': 'Apple airplay', 'value': true select 'id': 'kernel_profile', 'element': 'select', 'label': 'Kernel profile', 'value': {'value': 2 ,'label': 'Less Jitter'}, 'options': [ { 'value': 1, 'label': 'Default' }, { 'value': 2, 'label': 'Less Jitter' }, { 'value': 3, 'label': 'Jitter' }, { 'value': 4, 'label': 'Focus' } ] button 'id': 'update', 'element': 'button', 'label': 'System updates', 'description': 'You can check?...', 'onClick': { 'type': 'emit', 'data': 'search-for-upgrade', 'message': 'updateCheck', 'askForConfirm': {'title': 'Confirm', 'message': 'are you sure?'} Equalizer 'id': 'eq', 'type': 'section', 'label': 'Equalizer', 'onSave': { 'type': 'plugin', 'endpoint': 'music_services\/eq', 'method': 'saveEqValues' }, 'saveButton': { 'label': 'Save eq settings', 'data': [ 'bandEqualizer', 'equalizerSelector' ] }, 'content': [ { 'id': 'eq_switch', 'element': 'switch', 'label': 'Test eq switch', 'value': true }, { 'id': 'bandEqualizer', 'element': 'equalizer', 'label': 'Music EQ', 'description': 'Desc', 'visibleIf': {'field': 'eq_switch', 'value': true}, 'config': { orientation: 'vertical', bars: [ { min: -100, max: 100, step: 20, value: 20, tooltip: 'always' }, { min: 0, max: 50, step: 20, value: 25, tooltip: 'hide' }, { min: 0, max: 50, step: 20, value: 25, tooltip: 'always' } ] } } Equalizer Selector { 'id': 'equalizerSelector', 'element': 'equalizer', 'label': 'Slider selector', 'description': 'Desc', 'config': { orientation: 'horizontal', bars: [ { min: 0, max: 50, step: 10, value: [10, 20], range: true, tooltip: 'always' }, { ticks: [1, 2, 3], ticksLabels: ['Min', 'Medium', 'Max'], value: 2, tooltip: 'show' }, { ticks: [1, 2, 3, 4, 5], ticksPositions: [0, 20, 40, 80, 100], ticksLabels: ['1', '2', '3', '4', '5'], tickSnapBounds: 20, value: 4, tooltip: 'show' }","tags":"","url":"Plugin_System\/UI_Configuration_Pages.html"},{"title":"Adding Compatibility to your DAC","text":"If you're an hardware Audio manufacturer and you've developed a brand new i2s DAC, making it compatible with Volumio is very easy. Prerequisites The kernel driver must be already present in the Kernel that Volumio uses. If that's not true, please contact us The dacs.json file Volumio stores all compatibility data for i2s dac in a single file: the dacs.json file, here's a brief extract of it : { &quot;devices&quot;:[ {&quot;name&quot;:&quot;Raspberry PI&quot;,&quot;data&quot;:[ {&quot;id&quot;:&quot;aoide-kazoo-dac&quot;,&quot;name&quot;:&quot;Aoide Kazoo DAC&quot;,&quot;overlay&quot;:&quot;aoide-kazoo-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;generic-dac&quot;,&quot;name&quot;:&quot;Generic I2S DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-dacplus&quot;,&quot;name&quot;:&quot;Hifiberry DAC Plus&quot;,&quot;alsaname&quot;:&quot;Hifiberry DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:&quot;HiFiBerry DAC+&quot;,&quot;i2c_address&quot;:&quot;4d&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;hifiberry-dac&quot;,&quot;name&quot;:&quot;Hifiberry DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-amp&quot;,&quot;name&quot;:&quot;Hifiberry Amp&quot;,&quot;overlay&quot;:&quot;hifiberry-amp&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Master&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-digi&quot;,&quot;name&quot;:&quot;Hifiberry DIGI&quot;,&quot;overlay&quot;:&quot;hifiberry-digi&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;iqaudio-dacplus&quot;,&quot;name&quot;:&quot;IQaudIO DAC Plus&quot;,&quot;overlay&quot;:&quot;iqaudio-dacplus,auto_mute_amp&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;iqamp-unmute.sh&quot;,&quot;i2c_address&quot;:&quot;4c&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;justboom-dac&quot;,&quot;name&quot;:&quot;JustBoom DAC Boards&quot;,&quot;overlay&quot;:&quot;justboom-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:[&quot;JustBoom DAC HAT&quot;,&quot;JustBoom DAC HAT V1&quot;,&quot;JustBoom DAC HAT V 10&quot;],&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;iqaudio-amp&quot;,&quot;name&quot;:&quot;IQaudIO Pi-DigiAMP+&quot;,&quot;overlay&quot;:&quot;iqaudio-dacplus,auto_mute_amp&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;iqamp-unmute.sh&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, ]}, {&quot;name&quot;:&quot;Odroid C1+&quot;,&quot;data&quot;:[ {&quot;id&quot;:&quot;odroid-hifi-shield&quot;,&quot;name&quot;:&quot;HiFi Shield&quot;,&quot;overlay&quot;:&quot;&quot;,&quot;alsanum&quot;:&quot;2&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;} ]} ]} What you need to do Basically edit the dac.json appropriately and send us a pull request. Here's what you need to change: Add your DAC under the specific device it's for, like Raspberry PI or Odroid id: An unique identifier. Lowercase and without spaces, possibly use the dt-overlay as id. name: the name that will represent your DAC overlay: mandatory for raspberry PI. The DTOverlay parameter, used to enable the DAC. If more than one, comma separate them. alsaname: if you know how your DAC is named by alsa, its a plus to have it declared here alsanum: leave it to 1 mixer: if your DAC has an hardware mixer, indicate it here, so it will be automatically configured script: if you need a script to be launched on start, write here the name and place the script inside the scripts folder eeprom_name:for Raspberry PI only. Volumio can automatically detect your DAC and configure it without user intervention. The auto-detection method works best by reading the eeprom that every HAT should have. Specifically, we look for the content of \/proc\/device-tree\/hat\/product . So indicate here such content. Arrays are also accepted, in case this varies over time. This will look like &quot;eeprom_name&quot;:[&quot;JustBoom DAC HAT&quot;,&quot;JustBoom DAC HAT V1&quot;,&quot;JustBoom DAC HAT V 10&quot;] i2c_address: for Raspberry PI only. As a fallback, we can detect also a specific DAC via its i2c address. Indicate it here. This is a fallback mechanism in case eeprom reading won't work. IMPORTANT: Many dacs can have the same i2c address so use it only if there isn't already another dac with the same address. needs_reboot: on Raspberry PI we can enable some DACs without rebooting, by appying the DTPARAM in userspace. This doesn't work with all dacs. So please try first with this set to no. If that works and you can hear sound, fine. If that does not happen it means that your DAC is not capable of being activated without rebooting, and set this to yes.","tags":"","url":"I2S_DACs\/Adding_Compatibility_to_your_DAC.html"},{"title":"Markdown Cheatsheet","text":"# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 ====== Alt-H2 ------ H1 H2 H3 H4 H5 H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 Alt-H2 Emphasis Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. Strikethrough uses two tildes. ~~Scratch this.~~ Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. Lists (In this example, leading and trailing spaces are shown with with dots: \u00e2\u008b\u0085) 1. First ordered list item 2. Another item \u00e2\u008b\u0085\u00e2\u008b\u0085* Unordered sub-list. 1. Actual numbers don't matter, just that it's a number \u00e2\u008b\u0085\u00e2\u008b\u00851. Ordered sub-list 4. And another item. \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085To have a line break without a paragraph, you will need to use two trailing spaces.\u00e2\u008b\u0085\u00e2\u008b\u0085 \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085Note that this line is separate, but within the same paragraph.\u00e2\u008b\u0085\u00e2\u008b\u0085 \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) * Unordered list can use asterisks - Or minuses + Or pluses First ordered list item Another item Unordered sub-list. Actual numbers don't matter, just that it's a number Ordered sub-list And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses Links There are two ways to create links. [I'm an inline-style link](https:\/\/www.google.com) [I'm an inline-style link with title](https:\/\/www.google.com \"Google's Homepage\") [I'm a reference-style link][Arbitrary case-insensitive reference text] [I'm a relative reference to a repository file](..\/blob\/master\/LICENSE) [You can use numbers for reference-style link definitions][1] Or leave it empty and use the [link text itself]. URLs and URLs in angle brackets will automatically get turned into links. http:\/\/www.example.com or &lt;http:\/\/www.example.com&gt; and sometimes example.com (but not on Github, for example). Some text to show that the reference links can follow later. [arbitrary case-insensitive reference text]: https:\/\/www.mozilla.org [1]: http:\/\/slashdot.org [link text itself]: http:\/\/www.reddit.com I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself. URLs and URLs in angle brackets will automatically get turned into links. http:\/\/www.example.com or http:\/\/www.example.com and sometimes example.com (but not on Github, for example). Some text to show that the reference links can follow later. Images Here's our logo (hover to see the title text): Inline-style: ![alt text](https:\/\/github.com\/adam-p\/markdown-here\/raw\/master\/src\/common\/images\/icon48.png \"Logo Title Text 1\") Reference-style: ![alt text][logo] [logo]: https:\/\/github.com\/adam-p\/markdown-here\/raw\/master\/src\/common\/images\/icon48.png \"Logo Title Text 2\" Here's our logo (hover to see the title text): Inline-style: Reference-style: Code and Syntax Highlighting Code blocks are part of the Markdown spec, but syntax highlighting isn't. However, many renderers -- like Github's and Markdown Here -- support syntax highlighting. Which languages are supported and how those language names should be written will vary from renderer to renderer. Markdown Here supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the highlight.js demo page. Inline `code` has `back-ticks around` it. Inline code has back-ticks around it. Blocks of code are either fenced by lines with three back-ticks ```, or are indented with four spaces. I recommend only using the fenced code blocks -- they're easier and only they support syntax highlighting. ```javascript var s = \"JavaScript syntax highlighting\"; alert(s); ``` ```python s = \"Python syntax highlighting\" print s ``` ``` No language indicated, so no syntax highlighting. But let's throw in a &lt;b&gt;tag&lt;\/b&gt;. ``` var s = \"JavaScript syntax highlighting\"; alert(s); s = \"Python syntax highlighting\" print s No language indicated, so no syntax highlighting in Markdown Here (varies on Github). But let's throw in a &lt;b&gt;tag&lt;\/b&gt;. Tables Tables aren't part of the core Markdown spec, but they are part of GFM and Markdown Here supports them. They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from another application. Colons can be used to align columns. | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown | Less | Pretty --- | --- | --- *Still* | `renders` | **nicely** 1 | 2 | 3 Colons can be used to align columns. Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown Less Pretty Still renders nicely 1 2 3 Blockquotes &gt; Blockquotes are very handy in email to emulate reply text. &gt; This line is part of the same quote. Quote break. &gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. Inline HTML You can also use raw HTML in your Markdown, and it'll mostly work pretty well. &lt;dl&gt; &lt;dt&gt;Definition list&lt;\/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;\/dd&gt; &lt;dt&gt;Markdown in HTML&lt;\/dt&gt; &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;\/em&gt;.&lt;\/dd&gt; &lt;\/dl&gt; Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags. Horizontal Rule Three or more... --- Hyphens *** Asterisks ___ Underscores Three or more... Hyphens Asterisks Underscores Line Breaks My basic recommendation for learning how line breaks work is to experiment and discover -- hit &lt;Enter&gt; once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You'll soon learn to get what you want. \"Markdown Toggle\" is your friend. Here are some things to try out: Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a *separate paragraph*. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the *same paragraph*. Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also begins a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph. (Technical note: Markdown Here uses GFM line breaks, so there's no need to use MD's two-space line breaks.) Youtube videos They can't be added directly but you can add an image with a link to the video like this: &lt;a href=\"http:\/\/www.youtube.com\/watch?feature=player_embedded&amp;v=YOUTUBE_VIDEO_ID_HERE \" target=\"_blank\"&gt;&lt;img src=\"http:\/\/img.youtube.com\/vi\/YOUTUBE_VIDEO_ID_HERE\/0.jpg\" alt=\"IMAGE ALT TEXT HERE\" width=\"240\" height=\"180\" border=\"10\" \/&gt;&lt;\/a&gt; Or, in pure Markdown, but losing the image sizing and border: [![IMAGE ALT TEXT HERE](http:\/\/img.youtube.com\/vi\/YOUTUBE_VIDEO_ID_HERE\/0.jpg)](http:\/\/www.youtube.com\/watch?v=YOUTUBE_VIDEO_ID_HERE) Referencing a bug by #bugID in your git commit links it to the slip. For example #1.","tags":"","url":"Good_to_Knows\/Markdown_Cheatsheet.html"},{"title":"Mounting an NFS Share","text":"Adding Music from a shared folder on a Synology tested on Synology DS412 in combination with Volumio 0.978 for Raspberry Pi 3 Since both Synology and Volumio for Raspberry PI are Unix based the preference is to use NFS type file sharing. For more information visit: https:\/\/en.wikipedia.org\/wiki\/Network_File_System Synology preparation To enable NFS on Synology follow the detailed guide from Synology [https:\/\/www.synology.com\/en-global\/knowledgebase\/DSM\/tutorial\/File_Sharing\/How_to_access_files_on_Synology_NAS_within_the_local_network_NFS] The guide will explain in great detail the steps required. The final NFS rule configuration is shown in the screenshot. The most important part is the Squash setting. The required access is RW and since it's wise to disable the Guest account on your Synology, the Squash setting must be set to Map all users to admin. Volumio preparation Go to settings &gt; My Music Add New Drive Make sure you configure the share as shown in the screenshot. volume1 is normally the first part of the path, followed by the name of your share. In this case Music Since we shared using NFS no username and password is required and","tags":"","url":"Good_to_Knows\/Mounting_an_NFS_Share.html"},{"title":"Contribute to this Doc","text":"Everyone knows how tedious is to write documentation. But this is extremely important for every project, especially for Volumio. So if you find something incomplete, missing or wrong feel free to edit this doc and improve it. How this doc works This DOC is powered by DAUX.IO and the source is hosted on the Gitghub Volumio docs repository. To edit it, simply clone it, edit the pages located under \/docs and issue a pull request. You can do either via command line or with a graphical tool, I personally suggest GitKraken. Cloning and issing a Pull request Clone it https:\/\/github.com\/volumio\/docs.git Edit it \u00e2\u008b\u0085\u00e2\u008b\u0085* I suggest Atom.io IDE together with Markdown Preview but any text editor will do \u00e2\u008b\u0085\u00e2\u008b\u0085* Make sure you comply with DAUX rules (if you crete a new page, don't use spaces but _ and make sure the name ends with .md) \u00e2\u008b\u0085\u00e2\u008b\u0085* This doc is written in Markdown language, and automatically converted to html. See the Markdown Cheatsheet to get used to it Commit it git commit -m &quot;Hey I changed this and that&quot; Issue a pull request Once your PR gets accepted, in 2 minutes your contribution will be available to the whole community. See changes live To see your changes live, just download and launch any XAMMP environment to expose a php-capable local web server, and clone the docs under your htdocs folder. Docs will update in realtime and will be available under http:\/\/localhost\/docs","tags":"","url":"Good_to_Knows\/Contribute_to_this_Doc.html"},{"title":"Connection Outside LAN","text":"Sometimes it might be useful to connect to Volumio from outside the LAN, via services like NO-IP. Volumio UI uses socket.io to communicate with the backend, so we must tell the UI to connect to the external IP rather than the LAN's IP. Tell the UI to bind to new IP If you want to achieve this, hardcode your public IP in [https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/http\/restapi.js](https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/http\/restapi.js line 49 res.json({ host: 'http:\/\/'+self.host}); your public ip instead of self.host","tags":"","url":"Good_to_Knows\/Connection_Outside_LAN.html"},{"title":"Command Line Client","text":"Volumio has a command line client which can be invoked with the command volumio By invoking it, you'll see the help output with a list of the available commands: Usage : volumio &lt;argument1&gt; &lt;argument2&gt; [[PLAYBACK STATUS]] status Gives Playback status information volume Gives Current Volume Information volume &lt;desired volume&gt; Sets Volume at desired level 0-100 [[PLAYBACK CONTROL]] play pause next previous [[VOLUMIO SERVICE CONTROL]] start Starts Volumio Service stop Stops Volumio Service restart Restarts Volumio Service Command Line Client Development The command line client is located at \/volumio\/app\/plugins\/system_controller\/volumio_command_line_client\/volumio.sh While some dynamic commands (like volume controls) are located at \/volumio\/app\/plugins\/system_controller\/volumio_command_line_client\/commands","tags":"","url":"Good_to_Knows\/Command_Line_Client.html"}]}